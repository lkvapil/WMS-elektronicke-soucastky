\chapter{Formální specifikace dotazů}
\label{chap:formalni}

Tato kapitola zavádí formální notaci pro popis dotazů nad datovým modelem
\wms{}. Notace je inspirována lambda kalkulem a množinovou algebrou a je
platformově nezávislá -- lze ji přímočaře přeložit do SQL (relační DB),
Cypher (grafová DB) nebo libovolného API dotazu.

%% ── Definice notace ──────────────────────────────────────────────────────────
\section{Definice notace}

\paragraph{Universum.}
$\mathcal{U}$ označuje množinu všech uzlů (objektů) v systému. Množiny jsou
reprezentovány jako charakteristické funkce; $x \in A$ je zkrácený zápis za
$(A\ x)$.

\paragraph{Selekce (filtr).}
Infixový operátor $\mathbin{/\!/}$ filtruje množinu:
\[
  A \mathbin{/\!/} \Lambda \;\coloneqq\; \{\, x \mid (x \in A) \wedge (\Lambda\, x) \,\}
\]

\paragraph{Transformace (map).}
Infixový operátor $\gg$ mapuje množinu:
\[
  A \gg f \;\coloneqq\; \{\, f(x) \mid x \in A \,\}
\]

\paragraph{Flatten.}
Funkce $\operatorname{flatten}$ sloučí množinu množin:
\[
  \operatorname{flatten}(M) \;=\; \bigcup M
\]

\paragraph{Skládání do struktury.}
Infixový operátor $\oplus$ vytváří strukturu z hodnot:
\[
  a \oplus b \;\coloneqq\; \operatorname{Struct}(a,\, b)
\]

\paragraph{Atributy.}
Tečková notace je zkratkou pro funkční zápis:
$s.\mathit{věk} \coloneqq \mathit{věk}(s)$.

\paragraph{Orientovaná hrana.}
$x \xrightarrow{\text{Relace}} y$ znamená $(x,y) \in \text{Relace}$.

%% ── Příklady dotazů ──────────────────────────────────────────────────────────
\section{Příklady dotazů nad modelem WMS}

\subsection{Součástky pod minimálním stavem}

Množina součástek, jejichž celkový stav zásob klesl pod minimum:

\[
  K_{\min}
  \;=\;
  \text{Komponenty}
  \mathbin{/\!/}
  \bigl(\lambda k \mid k.\mathit{totalStock} < k.\mathit{minStock}\bigr)
\]

kde $k.\mathit{totalStock}$ je agregovaná hodnota:

\[
  k.\mathit{totalStock}
  \;\coloneqq\;
  \sum_{\,z\,:\; k \xrightarrow{\text{ULOZENA\_NA}} z}
    z.\mathit{quantity}
\]

Výstupní projekce (jméno, číslo, stav):

\[
  K_{\min}
  \gg
  \bigl(\lambda k \mid k.\mathit{name} \oplus k.\mathit{partNumber} \oplus k.\mathit{totalStock}\bigr)
\]

\subsection{Celková hodnota skladu}

Suma hodnot všech zásob:

\[
  \mathit{HodnotaSkladu}
  \;=\;
  \sum_{z \in \text{Zásoby}} z.\mathit{quantity} \times z.\mathit{unitPrice}
\]

\subsection{Katalog součástek dodavatele}

Všechny součástky nabízené konkrétním dodavatelem $d_0$:

\[
  \operatorname{flatten}\!\Bigl(
    \bigl\{\, d_0 \,\bigr\}
    \gg
    \bigl(\lambda d \mid
      \bigl\{\, k \mid d \xrightarrow{\text{DODAVANA\_OD}} k \bigr\}
    \bigr)
  \Bigr)
\]

\subsection{Pohyby výdeje na projekt}

Pohyby typu \texttt{VYDEJ} navázané na projekt $p_0$, provedené za
dané časové období $[t_1, t_2]$:

\[
  \text{Pohyby}
  \mathbin{/\!/}
  \Bigl(
    \lambda m \mid
      m.\mathit{movementType} = \texttt{VYDEJ}
      \;\wedge\;
      m \xrightarrow{\text{VYDANA\_NA}} p_0
      \;\wedge\;
      t_1 \leq m.\mathit{createdAt} \leq t_2
  \Bigr)
\]

Výsledná projekce (součástka, množství, datum):

\[
  \ldots \gg
  \bigl(
    \lambda m \mid m.\mathit{component} \oplus m.\mathit{quantity} \oplus m.\mathit{createdAt}
  \bigr)
\]

\subsection{Složité dotazy -- inventurní rozdíly}

Položky inventury, kde se zjištěný počet liší od evidovaného
(schválené i neschválené):

\[
  \text{PolozkyInventury}
  \mathbin{/\!/}
  \bigl(\lambda p \mid p.\mathit{countedQty} \neq p.\mathit{expectedQty}\bigr)
  \gg
  \bigl(
    \lambda p \mid
      p.\mathit{component}
      \oplus p.\mathit{expectedQty}
      \oplus p.\mathit{countedQty}
      \oplus (p.\mathit{countedQty} - p.\mathit{expectedQty})
  \bigr)
\]

\subsection{Překlad do Cypheru (Neo4j)}

Dotaz z~\S5.1 (součástky pod minimem) v jazyce Cypher:

\begin{lstlisting}[language=SQL, caption={Cypher – součástky pod minimálním stavem}]
MATCH (k:Komponenta)
OPTIONAL MATCH (k)-[z:ULOZENA_NA]->()
WITH k, coalesce(sum(z.quantity), 0) AS totalStock
WHERE totalStock < k.minStock
RETURN k.name, k.partNumber, totalStock
ORDER BY (k.minStock - totalStock) DESC
\end{lstlisting}

\subsection{Překlad do SQL (PostgreSQL)}

Tentýž dotaz v SQL:

\begin{lstlisting}[language=SQL, caption={SQL – součástky pod minimálním stavem}]
SELECT
    k.name,
    k.part_number,
    COALESCE(SUM(z.quantity), 0) AS total_stock,
    k.min_stock,
    k.min_stock - COALESCE(SUM(z.quantity), 0) AS deficit
FROM komponenty k
LEFT JOIN zasoby z ON z.component_id = k.id
GROUP BY k.id, k.name, k.part_number, k.min_stock
HAVING COALESCE(SUM(z.quantity), 0) < k.min_stock
ORDER BY deficit DESC;
\end{lstlisting}
